---
layout: single
title: "Chapter11. 포인터(4)"
---

# 간접 참조 연산자, 증감 연산자

- 증감 연산자(++, --)와 간접 참조 연산자(*)는 같이 사용될 수 있다.   
- *p++;  // p가 가리키는 위치에서 값을 가져온 후에 포인터 p를 증가한다.   
- *보다 ++의 우선 순위가 더 높지만, **가 포인터 뒤에 붙어 있으므로 *p를 먼저 수행한 후 p에 대하여 ++가 수행되는 것!   
- 포인터가 가리키는 대상의 값을 증가시키려면,   
(*p)++; 와 같이 작성   

v = *p++  // p가 가리키는 값을 v에 대입한 후에 p를 증가한다.   
v = (*p)++  // p가 가리키는 값을 v에 대입한 후에 p가 가리키는 값을 증가한다.   
v = *++p  // p를 증가시킨 후에 p가 가리키는 값을 v에 대입한다.   
v = ++*p  // p가 가리키는 값을 가져온 후에 그 값을 증가하여 v에 대입한다.   

# 포인터의 형변환

- 포인터의 타입을 변경할 때는 형변환 연산자를 써야 한다.   
double *pd = &f;   
int *pi;   

pi = (int *)pd;  // double형 포인터를 int형 포인터로 변환   
- 포인터의 타입을 바꾸어서 메모리에 접근할 때 조심한다. 접근 가능한 범위를 넘어서 이웃 바이트를 건드리면 안 된다.   

# 포인터와 함수

- 함수가 외부로부터 매개 변수를 통하여 데이터를 받는 방법 2가지   
  - 값에 의한 호출(call-by-value): 복사본이 전달된다.   
  - 참조에 의한 호출(call-by-reference): 원본이 전달된다.   
- C에서는 값에 의한 호출만을 지원한다.   
- 참조에 의한 호출(원본 전달)은 포인터를 이용하여서 간접 구현이 가능하다.   
 
- swap() 함수: swap(a, b)이면 변수 a와 변수 b의 값을 교환   
- main()에서는 변수 a와 변수 b의 값이 교환되지 않고, swap() 함수 안에서는 변수 x와 y의 값이 서로 바뀌었다.   
- 바뀐 x와 y의 값이 main()으로 전달되지 않은 이유는 C에서 함수 호출은 기본적으로 "값에 의한 호출"이기 때문이다! (값만 복사)   
- 즉, 복사본이 전달된 것으로 원본 변수 자체를 변경할 수 없는 것이다.   
