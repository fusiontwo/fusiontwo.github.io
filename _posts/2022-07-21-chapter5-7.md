---
layout: single
title: "Chapter5. 수식과 연산자(7)"
---

# 연산자 우선순위

+ 1순위   
'++,--' 후위 증감 연산자   
'()' 함수 호출   
'[]' 배열 인덱스 연산자   
'.' 구조체 멤버 접근   
'->' 구조체 포인터 접근   
'(type){list}' 복합 리터럴(C99 규격)   
---------------------------------------------결합성 →(좌에서 우)   
+ 2순위   
'++,--' 전위 증감 연산자   
'+,-' 양수 음수 부호   
'!,~' 논리적인 부정, 비트 NOT   
'(type)' 형변환   
'*' 간접 참조 연산자   
'&' 주소 추출 연산자   
'sizeof' 크기 계산 연산자   
_Alignof 정렬 요구 연산자(C11 규격)   
---------------------------------------------결합성 ←(우에서 좌)   
+ 3순위   
'*,/,%' 곱셈, 나눗셈, 나머지   
+ 4순위   
'+,-' 덧셈, 뺄셈   
+ 5순위   
'<< >>' 비트 이동 연산자   
+ 6순위   
'< <=' 관계 연산자   
'> >=' 관계 연산자   
+ 7순위   
'==,!=' 관계 연산자   
+ 8순위   
'&' 비트 AND   
+ 9순위   
'^' 비트 XOR   
+ 10순위   
'|' 비트 OR   
+ 11순위   
'&&' 논리 AND 연산자   
+ 12순위   
'||' 논리 OR 연산자   
---------------------------------------------결합성 →(좌에서 우)   
+ 13순위   
'?:' 삼항 조건 연산자   
+ 14순위   
'=' 대입 연산자   
'+=,-=' 복합 대입 연산자   
'*=,/=,%=' 복합 대입 연산자   
'<<=,>>=' 복합 대입 연산자   
'&=,^=,|=' 복합 대입 연산자   
---------------------------------------------결합성 ←(우에서 좌)   
+ 15순위   
',' 콤마 연산자   
---------------------------------------------결합성 →(좌에서 우)   

# 연산자 기능에 따른 우선 순위

콤마 < 대입 < 논리 < 관계 < 산술 < 단항   

# 우선 순위 지침

1. 괄호 연산자 () 우선 순위 높음.   
2. 모든 단항 연산자들은 이항 연산자들보다 우선 순위 높음. ++연산자는 +연산자보다 우선 순위 높음.   
3. 콤마 연산자를 제외하고 대입 연산자의 우선 순위가 가장 낮음. 단, 대입 연산자 우선 순위가 콤마 연산자보다는 높음.   
x = 2 + 3 , 2 - 3; // (x = 2 + 3), (2 - 3)   
4. 우선 순위가 생각나지 않으면 괄호를 이용해 정확히 지정하면 됨.   
(x <= 10) && (y >= 20)   
5. 관계 연산자나 논리 연산자는 산술 연산자보다 우선 순위가 낮음.   
x + 2 == y + 3 // (x+2) == (y+3)와 같다.   
6. 관계 연산자는 논리 연산자보다 운선 순위가 높음.   
x > y && z > y // (x > y) && (z > y)와 같다.   
7. 논리 연산자 중에서 && 연산자가 || 연산자보다 우선 순위가 높음.   
x < 5 || x > 10 && x > 0 // x<5 || (x>10 && X>0)와 같다.   
8. 계산 순서가 혼돈스러운 경우도 있음. 컴파일러에 따라 달라짐.   
수식 x*y + w*y 에서 x*y와 w*y가 + 연산보다 먼저 수행된다는 것은 명확, x*y와 w*y 중에서 어떤 것이 먼저 계산될지는 불명확   
(결합 규칙에 의하여 왼쪽에서부터 계산될 것이라 추측할 수 있으나, 결합 규칙은 피연산자를 공유하는 연산자들에게만 적용됨)   
9. 다음 수식은 왼쪽과 오른쪽 중 어떤 것이 먼저 실행되느냐에 따라 결과가 달라진다.   
x * y++ + w*y   
10. 또 다른 불명확한 수식   
x++ * x++; // x의 값은 얼마인가?   
x = x++; // x의 값은 얼마인가?   

# 결합 규칙

동일한 우선 순위의 연산이 있는 경우에 무엇을 먼저 수행하느냐에 대한 규칙   
+ 왼쪽 우선 결합 규칙(left-to-right) : 우선순위를 가지는 연산자들을 왼쪽에서 오른쪽으로 수행하는 것(문장에서 나타나는 순서대로 실행)   
  + 산술 연산자와 같은 대부분의 이항 연산자들은 왼쪽 우선 결합 규칙에 따름   
+ 오른쪽 우선 결합 규칙(right-to-left) : 오른쪽의 연산자부터 먼저 수행하는 것   
  + 대부분의 단항 연산자들과 대입 연산자는 오른쪽 우선 결합 규칙을 따름   
  ex) y = - ++ --x; // -(부호) 연산자 ++, --연산자는 모두 단항 연산자로서 오른쪽 우선 결합 규칙을 따름   
  --x → ++ → -- → 대입 연산자 순서로 수행됨   
  + 형변환 연산자도 단항 연산자로서 오른쪽 우선 결합 규칙에 따름   
  ex) f = (float)(long) i; // 변수 i는 먼저 long형으로 변환 → float로 변환 → 변수 f에 대입   
  y = a % b / c + d * (e - f) // (e-f) → a%b → a%b/c → d*(e-f) → a%b/c + d*(e-f) → y에 대입   

# 거듭제곱을 계산하는 연산자는 없지만, 함수가 있다

pow() : 헤더 파일 <math.h>에 있는 거듭 제곱을 계산하는 라이브러리 함수   
ex) 2의 3제곱값을 구하기   
double value = pow(2.0, 3.0)   






























