---
layout: single
title: "Chapter4. 변수와 자료형(4)"
---

# 컴퓨터에서 실수를 나타내는 방법1. 고정 소수점(fixed point) 방식

+ 소수점 위치를 고정   
+ 정수부와 소수부에 각각 일정 비트를 할당   
ex) 32비트로 실수 3.14 표현(3은 상위 16비트에, 0.14는 하위 16비트에 저장)   
0000 0000 0000 0011 0000 0000 0000 1110    

# 컴퓨터에서 실수를 나타내는 방법2. 부동 소수점(floating point) 방식

+ 같은 수의 비트를 사용해서 더 넓은 범위의 실수를 표현 가능   
ex) 32비트로 실수를 표현한다면 -> 상위 16비트는 부호있는 정수이어야 하므로 최고로 큰 수는 2^15-1 & 하위 16비트는 부호가 없어도 되므로 2^16-1   
+ 부동 소수점 : 소수점의 위치가 떠서 움직인다.   
ex) 149,598,000km를 부동 소수점 방식으로 나타내기   
부호 비트(1비트) + 가수 부분(23비트) + 지수 부분(8비트)   
=> (0 또는 1) + (1.49598) + (8) (여기서 '8'은 10의 8제곱이라는 뜻)   
+ 계산 속도 : 부동 소수점 방식 < 고정 소수점 방식 -> 부동 소수점 장치가 대부분 CPU에, 혹은 별도 포함   
+ 가수 부분은 실수의 정밀도를 나타냄 & 정밀도는 유효 숫자의 개수로 나타내며, 가수 부분에 몇 비트가 할당되느냐에 따라 결정됨   
+ 지수 부분은 실수의 표현 범위를 나타냄   

# 부동 소수점 자료형

float(32비트), double(64비트), long double(64비트)   
+ float 타입 : 32비트 중에서 24비트는 가수에, 8비트는 지수에 할당 / 유효 숫자 6자리까지 표현 가능 (0.12345678은 0.123456까지만 표현) / 지수의 범위는 10^-(38) ~ 10^38   
+ double 타입 : 64비트 중에서 53비트는 가수에, 11비트는 지수에 할당 / 유효 숫자 16자리까지 표현 가능 / 지수의 범위는 10^(-308) ~ 10^308   
+ PC에서 long double형은 double과 같다.   

# 실수를 출력하는 형식 지정자 %f

+ 실수는 소수점 6자리까지만 출력 가능, 소수점 6자리를 넘으면 반올림   
+ printf("%f", 0.123456789); // 0.123457 출력   
  + %10.3f : 실수의 전체 10자리 중에서 소수점 이하를 3자리로 출력   
  + %e 또는 %E : 실수를 지수 표기법으로 출력 ex) 1.2345e10 / 지수 부분을 나타내는 문자가 소문자인지 대문자인지만 다름   
  + %g : 소수점 이하 6자리 안에서 표현이 가능하면 %f 방식 사용 & 그렇지 않으면 %e 방식 사용   

# 부동 소수점 상수

+ 기본적으로 double형으로 저장 / 4-바이트 크기의 float형 상수를 만들려면 실수 상수 끝에 f나 F를 붙인다   
3.141592 //double형 상수(64비트)   
3.141592 //float형 상수(32비트)   


# 지수 표기법(세 번째 표기)

12345.6 = 1.23456 * 10^4 = 1.23456e4   

# 유효한 부동 소수점 상수 예시

+ 1.23456   
+ 2. // 소수점만 붙여도 된다.   
+ .28 // 정수부가 없어도 된다.   
+ 2e+10 // +나 -기호를 지수부에 붙일 수 있다.   
+ 9.26E3 // 9.26*10^3   
+ 0.67e-7 // 0.67*10^(-7)   
주의 : 소수부와 지수부 사이에 공백을 넣으면 안 됨 ex) 1.23 E30   

# 부동 소수점의 오버플로우

+ 오버플로우 : 변수에 대입된 수가 너무 커서 변수가 저장할 수 없는 상황   
+ 컴파일러는 해당 변수에 무한대를 의미하는 특별한 값을 대입 -> printf()는 이 값을 INF라고 출력   

# 부동 소수점의 언더플로우

+ 언더플로우 : 부동 소수점 수가 너무 작아서 표현하기가 힘든 상황   
+ 최대 정밀도 & 가장 작은 float형 부동 소수점 변수를 가정 -> 1.23456*10^(-38) (최대 6자리의 유효 숫자, 지수부 min = 10^(-38))   
if) 저장해야 하는 값이 1.23456*10^(-40) -> 지수부는 이미 가장 작은 값이므로, 컴퓨터는 가수부를 조정함 -> 0.0123456*10^(-38)   
-> 유효 숫자 6자리정도만을 저장할 수 있어서 실제 0.012345*10^(-38)로 저장   
+ 언더플로우가 일어나면 가수부가 부정확해짐 (가수부에 있는 값들이 정규 형태보다 더 작은 값을 가지게 하여 맞춤)  
+ 컴파일러가 가수부를 바꾸어 맞추는 것이 불가능하면, 그냥 0으로 만듬   

# 부동 소수형 사용 주의사항

항상 오차가 발생할 수 있음을 염두에 둔다   
1. 비트가 많아질수록 오차 감소   
2. float보다 double형을 사용하면 오차 감소   
 
# 오차 예시

+ double형의 변수에 계산식 (1*10^20+5.0)-1*10^20 의 결과값을 저장하면 5.0이 나와야 할 거 같지만, 0.0이 출력된다.   
이유 : 0이 20개나 붙는 1.0e20에 5를 더하면 10000000000000000005   
-> 정확하게 기억시키려면 유효숫자가 적어도 20개는 있어야 함   
-> 그래서 그냥 1.0e20으로 저장된다.   
if) 1.0e20 대신에 1.0e10을 사용했으면 정확한 결과를 얻을 수 있음   
