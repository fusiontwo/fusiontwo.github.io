---
layout: single
title: "Chapter11. 포인터(1)"
---

# 포인터(pointer)

- 포인터: 메모리의 주소를 가지고 있는 변수   
- 메모리(memory)는 바이트(byte) 단위로 주소가 매겨져 있다.   
- 컴퓨터 메모리에서 주소로 접근하여 값 저장과 읽기가 가능하다.   
- 변수는 메모리에 저장된다.   
- 메모리에서는 각 바이트마다 고유한 주소가 매겨진다.   
  - 20바이트의 메모리 -> 첫 번째 바이트의 주소는 0, 마지막 바이트의 주소는 19 (1씩 증가)   
- 만들어진 변수는 컴파일러에 의하여 메모리 공간의 비어있는 위치를 차지   
- char형 변수는 1 바이트, int형 변수는 4 바이트, float형 변수는 4 바이트   

# 주소 연산자 &

- 주소 연산자(address-of operator) &는 변수의 이름을 받아서 변수의 주소를 반환   
  - 변수 i의 주소는 &i   
- 메모리 공간에 변수를 배치하는 것은 컴파일러와 운영체제의 권한   
- 주소를 출력하는 형식 지정자   
  - %p: 주소를 16진수로 출력   
  - %u: 주소를 부호가 없는 10진 정수 형식으로 출력   

# 포인터의 선언

- 가리키는 것, 변수의 주소(메모리의 주소)를 가지고 있는 변수   
- 사용하기 전에 선언되어야 한다. (형식: int * p;)   
- 초기화하기 전에 포인터는 아무 의미 없는 값을 가진다.   

# 다양한 타입의 데이터를 가리키는 포인터

- 메모리상에서 주소는 동일한 크기이므로, 정수를 가리키는 포인터나 문자를 가리키는 포인터는 차이가 없다.   
- 그러면 왜 다양한 타입이 존재할까? 포인터가 가리키는 대상을 확실하게 하여 프로그래밍 실수를 예방하기 위해서이다.   
  - char *pc; // 문자를 가리키는 포인터 pc   
  - float *pf; // 실수(float형)를 가리키는 포인터 pf   
  - double *pd; // 실수(double형)를 가리키는 포인터 pd   

# 포인터 사용 주의사항

1. 여러 개의 포인터 변수를 한 줄에 선언할 때는 각각 선언해야 한다.   
- int *p1, p2, p3; // (x) p2와 p3는 정수형 변수가 된다.   
- int *p1, *p2, *p3 // (o) p2와 p3는 포인터 변수가 된다.   
2. 포인터의 사이즈   
- 32비트 운영체제에서 포인터는 4 바이트, 64비트 운영체제에서 포인터는 8 바이트이다.   
- sizeof(p)로 계산 가능   

# 포인터 초기화   

- 10000번지를 (int *) 타입으로 형변환하여서 포인터 p를 초기화한다.   
int *p = (int *)10000;   
- 아두이노에서 하드웨어는 메모리의 일부로 인식되고, 메모리의 특정 번지에 값을 쓰면 LED를 켜거나 끌 수 있다.   

- PC에서는 운영 체제가 메모리를 관리 -> 아래와 같이 절대 주소값을 대입하는 것은 피해야한다.   
char *p = (char *) 0x30000000;   
*p = 0;   
- & 연산자를 이용하여 변수의 주소를 계산하여 포인터에 대입할 수 있다.   
int i = 10;  // 정수 변수 i가 선언되고 10으로 초기화된다.   
int *p;  // 정수 포인터가 선언된다.   
p = &i;  // 포인터 p에 변수 i의 주소를 저장한다.   
- 위에서 변수 i의 주소가 4이었다면 -> p = &i의 연산을 실행했을 때 -> 변수 i의 주소인 4가 p에 대입된다.   

# 다양한 타입의 포인터 초기화

char c = 'A'  // 문자형 변수 c   
float f = 36.5;  // 실수형 변수 f   
double d = 3.141592;  // 실수형 변수 d   

char *pc = &c;  // 문자를 가리키는 포인터 pc   
float *pf = &f;  // 실수를 가리키는 포인터 pf   
double *pd = &d;  // 실수를 가리키는 포인터 pd   
