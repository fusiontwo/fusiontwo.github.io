---
layout: single
title: "Chapter9. 함수와 변수(1)"
---

# 변수의 속성

+ 변수가 함수 내부에 선언되느냐 외부에 선언되느냐에 따라 큰 차이   
+ 함수의 내부에서 선언된 변수는 함수 안에서만 사용 가능   
+ 변수는 이름, 타입, 크기, 값을 기본 속성으로 갖고, 범위, 생존시간, 연결의 속성도 갖는다.   
  1. 범위(scope) : 변수가 어떤 범위에서 사용이 가능한가이다. 가시성(visibility)이라고도 한다. 변수가 정의되는 위치에 따라 결정된다.   
  (블록 안에서 정의 -> 해당 블록으로 범위 제한, 함수 외부에서 정의 -> 전체 파일에서 사용 가능)   
  2. 생존 시간(lifetime) : 변수에게 할당된 기억 공간이 유지되고 변수가 메모리상에 존재하는 시간이다. 선언되는 위치에 따라 잠깐 생존했다가 없어지기도 한다.   
  3. 연결(linkage) : 서로 다른 파일에 존재하는 변수들을 사용할 수 있도록 연결하는데 사용되는 속성이다.   
  + 변수는 선언하는 위치, 저장 유형 지정자(storage class specifier)로 속성들을 변경할 수 있다.   

# 지역 변수와 전역 변수

선언되는 위치에 따라 지역 변수와 전역 변수로 나눈다.   
+ 지역 변수(local variable) : 함수 또는 블록 '안'에서 정의되는 변수. 해당 블록이나 함수 안에서만 사용 가능.   
+ 전역 변수(global variable) : 함수 '외부'에서 선언되는 변수. 소스 파일의 어느 곳에서도 사용 가능.   
+ 블록 : 중괄호로 둘러싸인 영역   

# 지역 변수

+ 예전 버전 C언어: 블록의 맨 첫 부분에서 지역 변수 정의해야 했음, 최신 버전 C언어: 블록의 어디서든지 변수 선언   
+ 변수는 사용하는 위치와 가까운 곳에서 선언하는 것이 좋다.   
+ 동일한 이름의 변수가 있어도 선언되어 있는 지역이 다르면 컴파일 오류가 발생하지 않는다.   
+ 지역 변수는 변수가 선언된 블록이 시작할 때 시스템 스택(stack)이라 불리는 메모리 공간에 만들어지며 동시에 초기화, 지역 변수에 할당된 메모리 공간은 블록 끝에서 반환되며, 지역 변수도 사라짐   
+ 지역 변수는 스택에 생성되며, 크기가 큰 지역 변수가 너무 많이 선언되면 스택 오버플로우 발생   
+ for 루프를 위한 중괄호도 블록에 속한다. for 루프 블록 내부에서 지역 변수를 선언하면 블록이 끝날 때 사라지므로 반복하여 값을 증가시킬 수 없다.   
+ 지역 변수를 초기화(초기 값을 정해주는 것)시키지 않고 값을 출력 -> 쓰레기 값(garbage value)이 들어서 비주얼 스튜디오 오류 발생   
+ 함수 헤더에 정의된 매개 변수도 지역 변수의 일종, 호출시의 인수 값으로 초기화되어 있음   
+ 매개 변수를 변경한다고 인수의 값이 변경되지는 않는다. 인수의 복사본이 매개 변수에 전달되므로 원래 인수는 영향을 받지 않는다.   
+ 값에 의한 호출(call by value) : 함수를 호출할 때 인수의 값이 매개 변수로 복사된다는 의미   
+ 참조에 의한 호출(call by reference) : 포인터를 학습할 때 다룸   

# 전역 변수

+ 전역 변수의 범위는 소스 파일 전체라서 모든 함수에서 접근 및 사용이 가능하다.   
+ 전역 변수를 초기화하지 않으면 컴파일러에 의하여 자동으로 '0'으로 초기화, 프로그램 시작과 동시에 생성되어 프로그램이 종료되기 전까지 메모리에 존재   
+ 전문가들은 전역 변수 사용을 권하지 않는다.   
  1. 프로그램이 복잡해지면 전역 변수를 어떤 부분에서 변경하고 있는지 알기 어렵다.   
  2. 하나의 함수 또는 전역 변수를 변경하려면 많은 다른 부분들도 변경해야 하는 경우가 흔하다.   
  + 스파게티 코드(spaghetti code) : 전역 변수들로 인하여 코드가 복잡하게 꼬이는 현상   
  + 모듈화 프로그래밍을 하려면 각 모듈의 독립성을 위해 전역 변수는 사용하지 않는 것이 좋다.   
+ 전역 변수가 효율적으로 사용되는 경우도 있다. 거의 모든 함수에서 사용하는 공통적인 데이터는 전역 변수로 할 수 있다.   
(일부의 함수들만 사용하는 데이터는 전역 변수로 하지 말고 함수의 인수로 전달한다.)   


# 같은 이름의 전역 변수와 지역 변수

+ 지역 변수가 전역 변수를 가린다.(지역 변수가 전역 변수보다 우선시된다.)   
+ 전역 변수 sum의 값은 1이고 지역 변수 sum의 값은 0이라면, sum을 출력했을 때 0이 나온다.   

# 변수의 생존 시간

+ 정적 할당(static allocation) : 프로그램이 실행되는 동안에는 계속하여서 변수에 저장 공간이 할당되어 있는 방법   
+ 자동 할당(automatic allocation) : 블록이 시작되면서 변수에 저장 공간이 할당되고 블록이 종료되면 저장 공간이 회수되는 방법   
+ 생존 시간 결정 요인   
  1. 변수가 선언되는 위치   
  전역 변수는 정적 할당, 지역 변수는 자동 할당(단, 지역 변수 앞에 저장 유형 지정자를 붙이면 정적 할당으로 변경 가능)   
  2. 저장 유형 지정자(storage class specifier) : 변수나 함수를 선언할 때에 어디에 저장되는 지를 지정한다.   
  (만약 저장 유형 지정자가 생략되면 변수가 선언되는 위치에 따라서 변수의 저장 유형이 자동으로 결정된다.)   
  ex) auto, register, static, extern   

# auto 지정자

+ 자동 변수(automatic variable) : 변수를 선언한 위치에서 생성되고 블록을 벗어나게 되며 자동으로 소멸   
+ 함수나 블록 안에 선언된 직역 변수는 auto가 생략되어도 모두 자동 변수로 취급된다.   

# static 지정자

+ 정적 변수(static variable) : 지역 변수처럼 블록에서만 사용되지만, 전역 변수처럼 블록을 벗어나도 자동으로 제거되지 않는 변수   
+ 정적 변수는 지역 변수와 전역 변수에 모두 붙일 수 있지만, 의미는 다르다.   
+ 정적 지역 변수는 자동 지역 변수와 달리 함수의 호출이 끝났어도 소멸되지 않는다.   
+ 정적 변수는 초기값을 지정하지 않으면 자동으로 0으로 초기화된다. 실행 도중에는 더 이상 초기화되지 않고, 초기화는 딱 한 번만 수행된다.   

# register 지정자

+ 레지스터 변수(register variable) : 변수를 메모리에 저장하지 않고, 레지스터에 저장한다.   
+ 레지스터는 CPU 안에 들어있는 저장공간으로, CPU만 사용하므로 데이터를 읽고 쓰는 속도가 아주 빠름   
+ 레지스터 변수는 지역 변수만 가능, 블록이 시작되면서 레지스트 변수는 할당되고 블록이 끝나면서 레지스터에서 제거됨   
+ 레지스터 개수는 제한되어 있음 -> 컴파일러는 최대한 많은 변수를 레지스터에 할당하려고 노력하지만, 불가능하면 컴파일러에 의해 레지스터 선언이 무시될 수 있음   
+ 레지스터 변수는 프로그램 실행 속도를 빠르게 함(루프 제어 변수는 레지스터로 하면 높은 성능 향상)   
+ 컴파일러는 항상 최적화 과정을 통하여 이미 CPU의 레지스터를 적절하게 사용하고 있음   
+ 레지스터 변수에는 주소를 추출한느 연산자 &을 적용하면 컴파일 오류 발생(레지스터는 주소가 없기 때문)   
ex) register int i;   
    p = &i; // 컴파일 오류   

# volatile 지정자

+ 컴파일러가 volatile 변수와 관련된 문장을 최적화하지 말라고 지시할 때 사용   
+ 하드웨어가 수시로 값을 변경 -> volatile로 지정된 변수의 값은 문장을 실행할 때마다 메모리에서 읽어야 함   
(코드에서는 전혀 변경되는 것 같지 않지만 하드웨어 장치가 불시에 변경 가능 -> 컴파일러가 한번만 읽어서 CPU 안의 레지스터에 저장해놓고 사용하면 안 됨)   

volatile int io_port; // 하드웨어와 연결된 변수   

void wait(void) {   
  io_port = 0;   
  
  while (io_port != 255)   
    ;   
}   

+ 컴파일러가 보기에는 io_port 변수의 값이 변경되지 않는 것 같지만, 하드웨어와 연결된 변수라면 하드웨어 장치가 이 변수를 255로 변경할 수 있다.   
+ volatile을 붙여서 실행할 때마다 메모리를 새로 읽으라고 해야 한다.   
