---
layout: single
title: "Chapter8. 함수(3)"
---

# 라이브러리 함수(수학 함수)

+ 라이브러리 함수를 사용하면 복잡한 산술 연산을 할 수 있다.   
+ 수학 함수들에 대한 원형은 헤더파일 <math.h>에 있고, 일반적으로 double형의 매개 변수와 반환값을 가진다.   
+ 삼각함수   
  + double sin(double x) 사인값 계산   
  + double cos(double x) 코사인값 계산   
  + double tan(double x) 탄젠트값 계산   
+ 역삼각함수   
  + double acos(double x) 역코사인값 계산 결과값 범위 [0, π]   
  + double asin(double x) 역사인값 계산 결과값 범위 [-π/2, π]   
  + double atan(double x) 역탄젠트값 계산 결과값 범위 [-π/2, π]   
+ 쌍곡선함수   
  + double cosh(double x) 쌍곡선 코사인   
  + double sinh(double x) 쌍곡선 사인   
  + double tanh(double x) 쌍곡선 탄젠트   
+ 지수함수   
  + double exp(double x) e^x ★   
  + double log(double x) log e X (e는 아래첨자) ★   
  + double log10(double x) log 10 X (10은 아래첨자) ★   
+ 기타함수   
  + double ceil(double x) x보다 작지 않은 가장 작은 정수   
  + double floor(double x) x보다 크지 않은 가장 큰 정수   
  + double fabs(double x) 실수 x의 절대값 ★   
  + int abs(int x) 정수 x의 절대값 ★   
  + double pow(double x, double y) x^y ★   
  + double sqrt(double x) 루트 x ★   

# floor()와 ceil() 함수

+ 2.31이라는 값이 있으면 floor()를 적용하면 2가 되고, ceil()을 적용하면 3이 된다.   
+ 헤더파일 <math.h>를 반드시 포함해야 한다.   

# fabs() 함수

+ fabs()는 실수를 받아서 절대값을 반환, 'float absolute'의 약자   
+ 절대값은 양수, 음수에 관계없이 그 수의 크기   
+ 절대값은 나이, 무게, 거리의 차이 계산에 유용   

# pow()와 sqrt() 함수

+ pow()는 제곱값을 계산, 'power(..제곱)'의 약자   
+ sqrt()는 값의 제곱근을 반환, 'square root(제곱근)'의 약자   

# cos(double x), sin(double x), tan(double x)

+ 삼각 함수의 값을 계산   
+ 각도는 라디안으로 표시, 1라디안은 180/π   
+ 라디안이 아닌 도 단위를 사용하려면 다음과 같이 변환   
degrees = (radians/3.141592)*180.0;   

# 기타 라이브러리 함수

많이 사용되는 유틸리티 함수   
+ exit(int status) : exit()를 호출하면 호출 프로세스를 종료시킨다. 프로세스 종료에 앞서서 모든 버퍼들은 비워진다. 보통 1을 인수로 주어서 호출하면 오류가 발생했다는 것을 의미한다.   
+ int system(const char *command) : system()은 문자열 인수를 운영 체제의 명령어 셀에게 전달하여서 실행시키는 함수이다. 외부에 실행시킬 수 있는 프로그램이 존재하는 경우에 사용할 수 있다. 예를 들어서 DOS 명령어인 DIR이나 TYPE, CLS, DEL, MKDIR와 같은 명령어들을 실행시킬 수 있다. 이 함수는 운영 체제에 의존적이다.   

# 함수를 사용하는 이유

1. 함수를 여러 번 호출하여 사용할 수 있어서, 소스 코드를 중복시키지 않는다.   
2. 한번 작성되고 디버깅 되어 있는 함수는 텍스트 에디터로 복사/붙여넣기하여 다른 프로그램에도 재사용할 수 있다.   
3. 대규모의 프로그램을 개발하고 유지보수하기 위해서는 작은 부분들로 나누어져 있는 것이 관리하기가 쉽다. -> 모듈(module)의 개념   
모든 작업을 main() 안에서 해도 실행은 되지만, 작은 작업들을 수행하는 함수들을 호출하는 것이 좋다.   
+ 각 함수들은 특징적인 한 가지 작업(기능)만을 맡아야 한다. -> 소스 코드의 가독성이 높아지고, 이름만 보아도 어떤 작업인지 알 수 있음   
+ 프로그램을 작성할 때 바로 타이핑부터 하지 말고, 전체 목적을 더 작은 작업들로 분리하여 설계가 끝나면 코딩을 시작하도록 한다.   

# 유용한 함수들
+ int get_integer(): 안내 메시지를 출력하고 정수를 받아서 반환한다.   
+ double get_double(): 안내 메시지를 출력하고 double형의 실수를 받아서 반환한다.   
+ char get_char(): 안내 메시지를 출력하고 문자를 받아서 반환한다.   

# 모듈

+ 대형 프로그램의 코드는 수만 라인이 넘는다. 시간이 지나면 이해하거나 디버깅하기 어렵다.   
+ 모듈(module) : 소프트웨어에서 코드를 작은 조각으로 분리한 것   
+ 모듈화 : 프로그램을 모듈로 구성하는 방법   

# 좋은 모듈화와 나쁜 모듈화

+ 모듈 내에서는 최대의 상호 작용(연관성), 모듈 사이에는 최소의 상호 작용(연관성)이 존재해야 한다.   
+ 모듈과 모듈 사이의 연결이 복잡하다면 모듈화가 잘못된 것이다.   
+ 모듈 내부의 응집도와 모듈 사이의 결합도로 설명하기도 한다.   

# 모듈 작성 방법

+ 가장 나쁜 예 : 전혀 관련이 없는 문장들을 모아서 모듈을 작성 -> 재사용성X   
+ 필요한 경우가 있지만 재사용이 어려운 경우 : 시간적이나 절차적으로 연관된 문장들을 모아서 모듈을 작성 ex) 초기화를 담당하는 init() 함수   
+ 가장 좋은 예 : 하나의 작업을 담당하는 문장들을 모아서 모듈을 작성 ex) printf(), write_to_printer(), sqrt()   

# 기능적인 응집력은 가지는 모듈이 좋은 이유

1. 하나의 모듈 안에서 한 가지 작업만을 수행하는 것이 오류를 줄일 수 있다.   
2. 모듈들은 재사용될 수 있어서 차기 프로그램의 개발을 빠르게 한다.   
3. 하나의 분리된 작업을 하나의 모듈이 담당함으로써 유지 보수성을 높일 수 있다. 특정 부분에서 오류가 발생하였다면 특정 모듈만 검사하면 된다.   

# 정보적 응집력과 객체 지향

+ 정보적 응집력 : 하나의 데이터를 공유하는 많은 작업들을 모듈 안에 하나로 묶은 것   
-> 객체 지향에서 이야기하는 '객체'의 개념이 된다.   
+ 객체지향 언어처럼 데이터와 연산을 하나로 묶는 도구가 없다고 할지라도 C를 사용할 때도 관련된 데이터와 연산들을 하나로 묶어서 프로그램하는 것이 중요하다.    

# main 함수가 반드시 프로그램의 처음에 나와야 하는가?

No!! main()이 맨 처음으로 실행되는 함수이지만 소스 파일에서의 위치는 아무런 상관이 없다.   

# 함수가 2개 이상의 값을 반환하게 하려면?

1. 매개 변수로 포인터를 사용한다.   
2. 구조체를 반환한다.   
3. 전역 변수를 사용한다.   

# 컴파일 오류 예시

int main(void)   
{   
    sub();   
    return 0;   
}   
void sub()   
{   
}   
1. sub() 함수의 원형이 정의되지 않았다.   
2. 컴파일러는 sub() 함수가 int 값을 반환한다고 가정하였으나, 뒤에 등장한 sub() 함수는 void 반환형을 가지기 때문에 반환형이 맞지 않는다.   
