---
layout: single
title: "Chapter10. 배열(2)"
---

# 배열의 초기화

+ 배열은 여러 개의 변수가 모인 것 -> 초기값도 하나가 아니고 여러 개가 필요   
+ 초기값들을 콤마로 분리하여 중괄호 {}로 감싼 후에, 배열을 선언할 때 대입   
+ 모든 배열 요소에 초기값을 부여하는 것이 원칙   
+ 초기값의 개수 < 요소들의 개수 -> 앞에 있는 요소들만 초기화됨   
int scores[5] = {10, 20, 30}; 에서   
scores[0] = 10, scores[1] = 20, scores[2] = 30 으로 초기화 되지만, scores[3], scores[4]는 0으로 초기화됨   

+ 배열의 모든 요소를 0으로 초기화하려면?   
int scores[5] = { 0 };   
+ 초기화만 하고 배열의 크기를 비워놓으면?   
컴파일러가 자동으로 초기값들의 개수만큼의 배열의 크기를 잡는다.   
int score[ ] = {10, 20, 30, 40, 50}   
+ 초기값이 주어지지 않았고 지역 변수로 선언된 배열이라면?   
일반적인 지역 변수와 마찬가지로 아무 의미없는 쓰레기값이 들어가게 된다.   
int main(void)   
{   
  int scores[5];   
  ...   
}   
scores[0], scores[1], scores[2], scores[3], scores[4]에 쓰레기값이 들어간다.   

주의사항 : 배열의 모든 요소를 10으로 초기화할 때 다음과 같이 작성하면 오류   
int scores[10] = { 10 };   
첫 번째 요소만 10이 되고 나머지 요소는 전부 0이 된다.   

+ 배열에서 초기화할 때를 제외하고는 중괄호로 값을 묶어서 대입할 수 없다. 배열에 값을 저장하려면 반드시 각 배열 요소에 값을 대입하여야 한다.   
아래와 같이 하면 오류 발생   
#define SIZE 3   
int main(void)   
{   
  int scores[SIZE];   
  scores = {6, 7, 8}; // 컴파일 오류!!   
}   

# 배열 요소의 개수를 계산하는 방법

+ 배열의 크기를 명시적으로 지정하지 않고 주어진 초기값의 개수로 결정하는 경우, 초기값의 개수를 매번 세어보아야 한다. -> 초기값의 개수가 많을수록 어려워짐   
int scores[] = { 6, 3, 1, 5, 8, 9, 0, 4, 4, 3, 7 , 9, 2, 1, 8, 5, 4, 2, 9}   
+ sizeof 연산자 : 자료형이나 변수의 크기를 바이트 단위로 계산하는 연산자   
+ 배열 전체의 크기를 구하고 이것을 배열 요소의 크기로 나누게 되면 배열 요소가 몇 개나 있는지 쉽게 계산할 수 있음   
int size = sizeof(scores) / sizeof(scores[0]);   
(배열의 크기 = 전체 배열의 크기 / 배열 요소의 크기)   

# 배열의 복사

+ 잘못된 방법: 배열의 이름을 다른 배열에 대입한다고 해서 배열이 복사되지 않는다.   
int a[SIZE] = {1, 2, 3, 4, 5};   
int b[SIZE];   
  
b = a;   
+ 올바른 방법: 하나의 배열을 다른 배열로 복사하기 위해서는 반복 루프를 사용하여 요소의 개수만큼 반복하면서 각각의 요소를 복사해주어야 한다.      
int i;   
int a[SIZE] = {1, 2, 3, 4, 5};   
int b[SIZE];   
  
for(i = 0; i < SIZE; i++)   
  b[i] = a[i];   
  
# 배열의 비교

+ 잘못된 방법: 배열의 이름은 배열이 저장된 메모리와 같고, 주소는 서로 다를 수밖에 없다. 배열 요소들의 값이 일치해도 항상 같지 않다는 메시지가 출력된다.   
int a[SIZE] = {1, 2, 3, 4, 5};   
int b[SIZE] = {1, 2, 3, 4, 5};   
if( a == b )   
  printf("같습니다.\n");   
else   
  printf("다릅니다\n");   

+ 올바른 방법: 반복 루프를 사용하여 요소의 개수만큼 반복하면서 각각의 요소를 비교해주어야 한다.   
int a[SIZE] = { 1, 2, 3, 4, 5 };   
int b[SIZE] = { 1, 2, 3, 4, 5 };   

for(i = 0; i < SIZE ; i++)   
{   
  if ( a[i] != b[i] )   
  {   
    printf("다릅니다.\n");   
    break;   
  }   
}   
a[i]가 b[i]와 같지 않으면 for 루프는 중단됨 -> for 루프가 중단되지 않고 종료하였다는 것은 모든 배열 요소가 일치함을 의미   
