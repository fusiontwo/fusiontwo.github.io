---
layout: single
title: "Chapter11. 포인터(2)"
---

# NULL

- NULL은 stdio.h 헤더 파일에 #define NULL ((void *)0)과 같이 정의됨. (포인터 상수로 0번지를 의미)   
- 0번지는 일반적으로 사용할 수 없고, CPU가 인터럽트를 위하여 사용한다.   
- 포인터 변수의 값이 0이면 아무 것도 가리키고 있지 않다.   

# 포인터의 중요성

- 포인터는 C언어를 다른 프로그래밍 언어들과 차별화시키는 특징이다.   
- 포인터를 이용하여 기계어나 어셈블리 언어처럼 주소를 가지고 직접 컴퓨터의 메모리에 접근해서 메모리를 조작할 수 있다.   
- 엠베디드 시스템에서 C언어가 널리 사용되는 이유이다.   

# 포인터를 사용하는 이유

- 데이터의 복사를 피하고 데이터를 공유하여 작업하고자 할 때 포인터를 사용한다.   
- 연결 리스트라는 자료 구조에서는 데이터들이 포인터를 이용하여 서로 연결된다.   
- 동적 메모리는 포인터로만 사용이 가능하다.   
- 자바나 파이썬에도 포인터가 있지만, 개발자가 마음대로 사용할 수는 없다.   

# 간접 참조 연산자 *

- 포인터는 단순히 메모리의 주소만 저장할 수 있는 변수라기보다는, 포인터를 이용해 값을 읽어오거나 값을 변경할 수 있다는 점에서 유용하다.   
- 저장된 내용을 읽으려면 포인터 이름 앞에 * 기호를 붙인다. ex) *p   
- 위의 내용은 포인터를 통하여 메모리를 간접 참조(dereferencing, indirection)하는 것이다.   
int i = 10;  // 정수 변수 i가 선언되고 10으로 초기화된다.   
int *p;  // 정수 포인터가 선언된다.   
p = &i;  // 포인터 p에 변수 i의 주소를 저장한다.   
printf("%d \n", *p);  // 10이 출력된다.   
- 포인터를 이용하면 간접적으로 변수의 내용을 변경할 수도 있다.   

# 간접 참조 연산자 * 의 해석

- *p는 p가 가리키는 위치에 있는 데이터를 가져오라는 의미이다.   
- 포인터의 타입이 있어야 포인터를 이용하여 데이터를 읽어 들일 때 몇 개의 바이트를 읽어야 할지 알 수 있다.   
  - int형 포인터이면 p가 가리키는 위치에 정수가 있다고 가정하고 4바이트를 읽어 들인다.   
  - double형 포인터이면 p가 가리키는 위치에 실수가 있다고 생각하고 8바이트를 읽어 들인다.   

- 엠베디드 시스템이라서 메모리를 마음대로 관리할 수 있다고 가정하자.   
(아두이노에서는 절대 주소를 사용할 수 없고, 윈도우에서는 절대 주소를 사용하면 실행 오류가 발생한다.)   
int *pi = (int *)10000;  // int형 포인터이므로 10000번지부터 4바이트를 읽게 된다.   
char *pc = (char *)10000;  // char형 포인터이므로 10000번지부터 1바이트를 읽게 된다.   
double *pd = (double *)10000;  // double형 포인터이므로 10000번지부터 8바이트를 읽게 된다.   

# & 연산자와 * 연산자 비교

- & 연산자: 변수의 주소를 구하여 포인터에 대입할 때 사용됨.   
- * 연산자: 포인터를 통하여 변수를 간접 참조할 때 사용됨.   
