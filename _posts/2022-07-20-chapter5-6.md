---
layout: single
title: "수식과 연산자(6)"
---

# 형변환(type conversion)

실행 중에 데이터의 타입을 변경하는 것, 데이터 일부가 사라지지 않도록 주의   
1. 자동적인 형변환(by 컴파일러)   
대입연산시 형변환, 정수연산시 형변환, 수식연산시 형변환   
2. 명시적인 형변환(by 프로그래머)   
(자동 형변환과 명시적인 형변환의 결과가 다른 경우도 있어서 적절한 판단 필요)   

# 대입연산시 자동적인 형변환

대입 연산자의 오른쪽에 있는 값은 왼쪽에 있는 변수의 자료형으로 자동적으로 변환된다.   
+ 올림 변환(promotion)   
double f;   
f=10; // f에 10.0이 저장된다.   
f가 double형일 경우, 10이 double형으로 변환된 후에 변수 f로 대입   
+ 내림 변환(demotion)   
  + 낮은 등급의 자료형으로 변환되며, 데이터의 손실이 발생할 수 있음   
  + 내림 변환이 일어나지 않도록 주의해야 하며, 컴파일러에서도 내림 변환이 일어나면 경고 메시지를 출력함   
  + 부동소수점수가 정수형 변수로 대입되면 소수점 이하는 버려짐  
  int i;   
  i = 3.141592; // i에는 3이 저장된다.   
  + 정수형끼리도 내림 변환 가능   
  4바이트인 int형을 1바이트인 char형에 대입하면 하위 1바이트를 제외한 상위 3바이트는 버려짐   

# 정수 연산시 자동적인 형변환

x + y 이 수식에서~  
+ x와 y가 int형 변수라면 -> 수식의 결과도 당연히 int형   
+ x와 y가 char형 변수이거나 short형 변수라면 -> 수식의 결과도 int형!!   
이유: 컴파일러가 char형이나 short형이 수식에 등장하면 이것을 자동으로 int형으로 승격시킴(정수형 연산을 하나로 통일하여 실행)   

# 레지스터와 int형

+ 레지스터(register) : CPU가 사용하는 가장 빠른 내부기억장소 -> 레지스터를 이용하여 산술 연산   
+ CPU 안의 모든 레지스터의 크기 = int형의 크기 -> int형은 가장 자연스럽게 CPU가 처리할 수 있는 크기   

# 수식 연산시의 자동적인 형변환

+ 원칙 : 수식의 피연산자로는 동일한 자료형만을 사용해야 함   
+ 실제 : 서로 다른 자료형이 같은 수식에서 혼합되어서 사용되는 경우 발생   
+ 하나의 수식에서 서로 다른 자료형이 사용되면, 데이터의 손실을 막기 위해서 가장 높은 등급의 자료형으로 자동 변환됨   
+ ★낮은 등급에서 부터 높은 등급 순으로 나열하면 int, unsigned int, long, unsigned long, float, double, long double   
+ 위에 char와 short가 없는 이유는 이미 int형으로 변환되었기 때문   
+ 10+1.2345에서는 10이 'double형인 10.0'으로 변환된 후에 10.0+1.2345가 실행되고 결과는 double형 11.2345   

# 명시적인 형변환 : 형변환(type cast) 연산자 (캐스트 연산자)

원하는 자료형을 괄호 안에 넣고 상수나 변수 앞에 적는다.   
+ 형변환을 한다고 해서 변수의 형이 변환되는 것이 아님, 변수의 값만이 형변환됨.   
+ (int)1.23456 // int형으로 변환(값이 1이 됨)   
+ (double) x // 변수 x의 값이 double형으로 변환   
+ (long) (x+y) // 수식의 값이 long형으로 변환   
